# -*- coding: utf-8 -*-
"""ProjetS5_Partie_Hang.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GoWPk9_esSA17Y5rBSQNZZGpf_F-md70

#----------------ProjetS5, IMT-Atlantique & SHOM----------------
Professeur : Cécile Bothorel

Client : Thierry Schmitt, Eric Le Guen, Julian LE DEUNF

Elèves : Hang ZHANG, Zheng YUAN, Xue WANG, Runlu QU

@Author - Hang ZHANG, Zheng YUAN, Xue WANG, Runlu QU, 03/2020.

-----------Map clean & Target detect functions--------------
"""

from PIL import Image, ImageDraw, ImageEnhance, ImageFilter
import numpy as np
import glob as gb
import copy
import cv2
import os


SAVE_PATH = './result/principal_1_detected_images_to_rotate'

CLEAR_DOT_LIKE_THRESHOLD_1 = 5
CLEAR_DOT_LIKE_THRESHOLD_2 = 3

LENGTH_THRESHOLD, THICKNESS = 15, 5
NUM_SIZE = 14
min_contour_area = 0.1 * NUM_SIZE * NUM_SIZE
max_contour_area = 10 * NUM_SIZE * NUM_SIZE
min_width, max_width = NUM_SIZE - 4, NUM_SIZE * 8
min_height, max_height = NUM_SIZE - 4, NUM_SIZE * 8


def show(img, name):
    # Image._show(img)
    img.save("./result/" + name + ".png", "png")

def ClearDotlikeNoise(data, k_threshold):
    '''
    Dot-like noises clear function by using 8-neighbor
    **************************************************************************************************
    ** For each black pixel(value=0) of the input image, find its nearest 8 neighbors, *
    ** if number of white pixels(value=255) is greater than k(threshold), then this   **
    ** black pixel will be judged as a noise and it will be set to a white pixel. **
    **************************************************************************************************
    Input：
    data - nyarray, data of the image to be treated.
     k - int, value of threshold.
    Output:
    nyarray, data of the image be treated.
    @author HangZHANG,IMT-Atlantique,03/2020
    '''

    height = data.shape[0]
    width = data.shape[1]

    # Traverse all pixels in this image
    for i in range(height):
        for j in range(width):
            if i == 0 or i == height - 1 or j == 0 or j == width - 1:
                data[i][j] = 255
                continue
            # Once find a black pixel(value=0), then use 8-neighbor noise clear algorithm
            if data[i][j] == 0:
                num = 0
                # Count number of black pixel in the 8-neighbors around this pixel
                for da in data[i - 1:i + 2, j - 1:j + 2]:
                    if da[0] == 0:
                        num += 1
                    if da[1] == 0:
                        num += 1
                    if da[2] == 0:
                        num += 1
                # If number of black pixel in the 8-neighbors around this pixel is less than k(threshold),
                # then this black pixel will be detected as a noise, set it to a white pixel(value=255).
                if num < k_threshold:
                    data[i][j] = 255

    return data


def FLD_ClearLinelikeNoise(data, length_threshold, thickness):
    '''
    Line-like noises clear function by using FLD
    **************************************************************************************************
    ** Use the build-in function cv2.ximgproc.createFastLineDetector to detect all lines ,**
    ** if length of a line is greater than length_threshold, then this line will be ***
    ** detected as a noise and will be set to a white line with width = thickness. **
    **************************************************************************************************
    Input：
    data - nyarray, data of the image to be treated.
    length_threshold - int, value of minimum length a line be detected as noises.
    thickness - int, width of the white line(set black line-like noises to white).
    Output:
    nyarray, data of the image be treated.
    @author HangZHANG,IMT-Atlantique,03/2020
    '''

    distance_threshold = 1.41421356
    canny_th1 = 50.0
    canny_th2 = 50.0
    canny_aperture_size = 3
    do_merge = False

    # Create a FastLineDetector with parameters
    fld = cv2.ximgproc.createFastLineDetector(length_threshold, distance_threshold,
                                              canny_th1, canny_th2,
                                              canny_aperture_size, do_merge)

    # Use FLD to detect all suitable lines
    lines = fld.detect(data)[:, 0, :]

    # Set all detected lines to white pixels(for gray input image)/color lines(for RGB input image).
    for x1, y1, x2, y2 in lines[:]:
        cv2.line(data, (x1, y1), (x2, y2), (255, 0, 255), thickness)

    return data


def floodFill_clear(data, k_min, k_max):
    '''
  Noises clear function by using cv2.floodFill
  *********************************************************************************************************
  ** Use the floodFill API of OpenCV to clear noises inside the input image according to **
  ** two parameters - k_min and k_max. FloodFill_clear function can count number of pixel  *
  ** of each inter-connected area. Only areas match k_min<=number of pixel<=k_max can retain,**
  ** other inter-connected areas will be set to white pixels(be removed).           **
  *********************************************************************************************************
  Input：
    data - nyarray, data of the image to be treated.
    k_min - min number of pixel that an keepable inter-connected area should have.
    k_max - max number of pixel that an keepable inter-connected area should have.
  Output:
    nyarray, data of the image be treated.
  @author HangZHANG,IMT-Atlantique,03/2020
  '''

    # Change the image from binary to RGB,
    # because we will need different value to count number of pixel in an inter-connected area.
    image = Image.fromarray(data)
    tmp_img = cv2.cvtColor(np.array(image.convert('RGB')), cv2.COLOR_RGB2BGR)

    h, w = tmp_img.shape[:2]
    mask = np.zeros((h + 2, w + 2), np.uint8)
    mask[:] = 255
    color = 1
    numm = 0

    # Traverse all black(vlue=0) pixels in this image, find out all inter-connected areas
    for x in range(w - 1):
        for y in range(h - 1):
            if (tmp_img[y, x] == 0).all():
                # Use cv2.floodFill to mark the inter-connected area that have been found.
                # The value of "color" changes for different inter-connected area.
                cv2.floodFill(tmp_img, mask, (x, y), (0, 0, color), cv2.FLOODFILL_MASK_ONLY)
                color = color + 1

    # Once traverse all inter-connected areas of this image,
    # count number of black pixels inside of each area.
    color_count = {}
    for x in range(w - 1):
        for y in range(h - 1):
            if (tmp_img[y, x] != 255).any():
                if (tmp_img[y, x][2]) in color_count:
                    color_count[tmp_img[y, x][2]] += 1
                else:
                    color_count[tmp_img[y, x][2]] = 1
                    numm = numm + 1

    # For each inter-connected area, if its number of black pixels is out of scope,
    # This area will be detected as a noise and be set to white area(value=255).
    for x in range(w - 1):
        for y in range(h - 1):
            if (tmp_img[y, x] != 255).any() and color_count[tmp_img[y, x][2]] <= k_min:  # 30
                # tmp_img[y, x] = (255, 0, 0)
                tmp_img[y, x] = (255, 255, 255)
                numm = numm - 1
            elif (tmp_img[y, x] != 255).any() and color_count[tmp_img[y, x][2]] >= k_max:  # 800
                # tmp_img[y, x] = (0, 255, 0)
                tmp_img[y, x] = (255, 255, 255)
                numm = numm - 1
            else:
                continue

    return cv2.cvtColor(tmp_img, cv2.COLOR_BGR2GRAY), numm


def location(load_path):
    '''
    First step, preparing work
    @author IMT-Atlantique,03/2020
    '''

    print("load image form ", load_path)
    # Load the colorful image
    img_org = cv2.imread(load_path)
    # Load the gray image
    image = cv2.imread(load_path, 0)

    print("handle image")
    # Gaussian smooth, size of kernel should changing according to the size of image
    blur = cv2.GaussianBlur(image, (3, 3), 0)

    # Transform the image to binary image
    ret, img_bin = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    ret2, img_bin2 = cv2.threshold(image, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

    # Take a first look at the smooth binary image to be treated
    img1 = Image.fromarray(img_bin)
    show(img1, "smooth binary image")

    # Take a first look at the binary image to be treated
    img2 = Image.fromarray(img_bin2)
    show(img2, "binary image")

    '''
    ##-----------------## Remove dot-like noises ##-----------------##
    @author IMT-Atlantique,03/2020
    '''
    img_dot_clear = copy.deepcopy(img_bin)
    # Use the same function 2 times with different thresholds
    print("clear dot like noise")
    img_dot_clear = ClearDotlikeNoise(img_dot_clear, CLEAR_DOT_LIKE_THRESHOLD_1)
    img_dot_clear = ClearDotlikeNoise(img_dot_clear, CLEAR_DOT_LIKE_THRESHOLD_2)

    '''
    ##-----------------## Remove line-like noises ##-----------------##
    Here are two parameters to control for removing line-like noises 
      length_threshold：The minimum length that a line-like thing can be detected as noise.
              with a big threshold it may can't detect small lines
              with a small threshold it may remove numbers like 1，7
      thickness：The thickness of the line that we want to remove.
              with a big thickness it may remove things around of detected line-like noises
              with a small thickness it may can't remove line-like noises clearly
    @author IMT-Atlantique,03/2020
    '''
    print("clear line like noise")
    img_line_clear = FLD_ClearLinelikeNoise(img_dot_clear, LENGTH_THRESHOLD, THICKNESS)

    '''
    ##-----------------## Copy to a new image ##-----------------##
    Here are parameters to control for detecting targets(numbers)
      num_size ：The length that a thing can be detected as target(numbers).
              with a big value it may detect big noises
              with a small value it may can't detect small numbers like 1，7
      min_contour_area：The minimum area of a thing that can be detected as target(numbers)
      max_contour_area：The maximum area of a thing that can be detected as target(numbers)
      min_width,max_width：Threshold of the width that a thing can be detected as target(numbers)
      min_height,max_height：Threshold of the height that a thing can be detected as target(numbers)
    @author IMT-Atlantique,03/2020
    '''

    # Set an all-white image having same size as the image treated.
    img_new = img_dot_clear.copy()
    img_new[:] = 255

    # Use cv2.findContours to detect all contours.
    # RETR_EXTERNAL # RETR_TREE
    print("find contours")
    npaContours1, npaHierarchy1 = cv2.findContours(img_line_clear, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

    # For each contour, detect its length and width and area then decide if we should take it.
    for npaContour in npaContours1:
        [intX, intY, intW, intH] = cv2.boundingRect(npaContour)
        if min_contour_area < cv2.contourArea(npaContour) < max_contour_area:
            if min_width < intW < max_width or min_height < intH < max_height:
                # Noise clear by using cv2.floodFill, it is more accurate than cv2.findContours.
                image01 = img_line_clear[intY:intY + intH, intX:intX + intW]
                image02, numm = floodFill_clear(image01, min_contour_area, max_contour_area)
                # Once clear all removeable noise, we put all things left into the new all-white image
                img_new[intY:intY + intH, intX:intX + intW] = image02

    '''
    ##-----------------## Make marks on all target-like areas ##-----------------##
    Before making value-area detect, need to connect distant numbers,
    if not, numbers like 4. 3 will be detected as 4 and 3, but not 4.3.
    The idea is to make a big mark for each area, this mark should not be much bigger 
    than area itself but able to touch other areas arounding, so we choose to use circle.
    The choice of center position and radius is important. Center should at the center of
    an area, radius should no bigger than half of the length of the numbers(here is 21).
    @author IMT-Atlantique,03/2020
    '''

    # Use cv2.findContours to find all contours in the image
    img_mark = img_new.copy()
    # RETR_EXTERNAL #RETR_TREE
    npaContours1, npaHierarchy1 = cv2.findContours(img_new, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

    for npaContour in npaContours1:
        [intX, intY, intW, intH] = cv2.boundingRect(npaContour)
        # Put a suitable circle on each suitable area, trying to connect numbers.
        if min_contour_area < cv2.contourArea(npaContour) < max_contour_area and min_width < intW < (
                max_width / 2) and min_height < intH < (max_height / 2):
            radius = min(int(max(intH, intW) / 2 * 1.1), int(NUM_SIZE / 2))
            cv2.circle(img_mark, (int(intX + intW / 2), int(intY + intH / 2)), radius, 0, -1)
        # Set all unsuitable areas to white rectangle(value=255).
        elif max_width < intW < (max_width * 10) or max_height < intH < (max_height * 10):
            cv2.rectangle(img_mark, (intX, intY), (intX + intW, intY + intH), 255, -1)

    img3 = Image.fromarray(img_mark)
    show(img3, "mark")

    '''
    ##-----------------## Detect targets(numbers) ##-----------------##
    After removing dot-like noises, line-like noises, unsuitable areas and connecting numbers,
    we can finally detect numbers on the marked image(img_mark) by using cv2.findContours.
    @author IMT-Atlantique,03/2020
    '''

    img_true_boxes = img_bin2.copy()  # img_bin2 img_bin img_org image
    bounding_box_list = []

    npaContours, npaHierarchy = cv2.findContours(img_mark, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

    for npaContour in npaContours:
        if min_contour_area < cv2.contourArea(npaContour) < max_contour_area:
            [intX, intY, intW, intH] = cv2.boundingRect(npaContour)
            # This time we should to set a bigger range since we "connect" numbers
            # by adding a suitable circle on suitable areas, which will make them bigger.
            if min_width < intW < (min_width * 5) and min_height < intH < (min_height * 5):
                cv2.rectangle(img_true_boxes, (intX, intY), (intX + intW, intY + intH), (0, 0, 255), 1)
                bounding_box_list.append([intX, intY, intW, intH])
            else:
                cv2.rectangle(img_true_boxes, (intX, intY), (intX + intW, intY + intH), (255, 0, 0), 1)
                # bounding_box_list.append([intX, intY, intW, intH])

    img4 = Image.fromarray(img_true_boxes)
    show(img4, "target")

    '''
    Where do you want to save your detected targets???
    @author IMT-Atlantique,03/2020
    '''
    return bounding_box_list, img_bin2

